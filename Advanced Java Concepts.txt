Name: Mootaz Medhat Ezzat Abdelwahab |ID: 20206074 |Group: S5 |Lab Slot: Wednesday[11:15-12:30] |Programming Language:[Java]
-----------------------------------------------------------------------------------------------------------------------------
> Variable Arguments (Varargs):-
   ___________________________________________________________________________
  |public class VarargsExample {                                              |
  |    // Takes double as a argument followed by variable number of strings   |
  |    static void display(double gpa, String... name) {                      |
  |        String sName = " ";                                                |
  |        for (String i : name) {sName = sName + i + " ";}                   |
  |        System.out.print("GPA : " + gpa + "\n" + "Name: " + sName + "\n"); | 
  |    }                                                                      |
  |    public static void main(String args[]) {                               |
  |        display(3.3);                     // GPA : 3.3 Name:               |
  |        display(3.3, "Mootaz");           // GPA : 3.3 Name: Mootaz        |
  |        display(3.3, "Mootaz", "Medhat"); // GPA : 3.3 Name: Mootaz Medhat |
  |        // error; varargs mismatch; double cannot be converted to String   |
  |        // display(3.3 , 2.5);            // Compile time error            |
  |}   }                                                                      |
  |___________________________________________________________________________|
  - There can be only one variable argument in the method and it must be the last argument:
    - static void display(double... gpa, String... name) // Compile time error.
    - static void display(double... gpa, String name)    // Compile time error.
  - Varargs were introduced in JDK 5. Before JDK 5 either we use overloaded method or put the arguments into an array and then take this array 
    as the method parameter. Which increases the length of the code; thereby reduces readability, writability and maintainability.
  - This technique enhances generality and at the same time does not affect reliability due to the presence of type checking at compile time. 
> Subprograms As Parameters (Function Pointer Simulation):-
   ___________________________________________________________________________
  |public class FunctionPointerEx {                                           |
  |    // Method that takes other method as a parameter                       |
  |    public static void hello(Runnable obj) {obj.run();}                    |
  |    // Methods to pass as arguments                                        |
  |    public static void english() {System.out.print("Hello" + "\n");}       |
  |    public static void french()  {System.out.print("Bienvenue" + "\n");}   |                                                 
  |    public static void main(String args[]) {                               |
  |        hello(FunctionPointerEx::english);  // prints "Hello"              |
  |        hello(FunctionPointerEx::french);   // prints "Bienvenue"          |
  |}   }                                                                      |
  |___________________________________________________________________________|
  - A function pointer is a pointer that points directly to the address of a function. Which optimizes memory consumption and enhances generality.
  - Java does not support function pointers in the same way C/C++ does because it doesn't have the concept of pointers "directly". But we can 
    simulate the behavior of function pointers either using method references or lambdas [ hello(() -> System.out.println("Hello")) ].
> There Are Two Types of Polymorphism in Java:-
  1) Static  Polymorphism: This type of polymorphism is achieved by using the method overloading. It decides which method to execute at compile-time.
  2) Dynamic Polymorphism: This type of polymorphism is achieved by using the method overriding . It decides which method to execute at run-time by the JVM.
     - Although all types in dynamic polymorphism are statically checked at compile-time, dynamic polymorphism simulates dynamic type binding where subprogram 
       calls bind to their subprograms based on the invoking object type which looks as if it checked at run-time. 
     - It happens between different classes:
       - superclass (interface/abstract) which have at least one puer virtual method. It just holds the address of an object from a subclass (derived class).
       - subclasses (concrete classes) which override the methods in the superclass to provide different functionalities.
     - Dynamic Polymorphism has little run-time overhead due to method forward calling during. Which may lead to run-time performance issues. 
> Generics (Generics Class and Methods):-
   _________________________________________________________________________________________________
  |public class GenericBubbleSort {                                                                 |
  |    // Generic method takes array of any type and sort array elements                            |
  |    public static <T extends Comparable<T> > void sort(T[] arr) {                                |
  |        for (int i = 0; i < (arr.length - 1); i++) {                                             |
  |            for (int j = 1; j < (arr.length - i); j++) {                                         |
  |                if (arr[j].compareTo(arr[j - 1]) < 0) {                                          | 
  |                    T t = arr[j]; arr[j] = arr[j-1]; arr[j-1] = t;  // swap                      | 
  |        }}}                                                                                      |
  |        for (T i : rra) { System.out.print(i + ", "); } // Printing array elements after sorting |
  |    }                                                                                            |
  |    public static void main(String args[]) {                                                     |
  |        Integer[]   arrofInt = {10, 5, 0, 3, 6, 1} ; sort(arrofInt);       // 0, 1, 3, 5, 6, 10, |
  |        Character[] arrofCha = {'v', 'g', 'a', 'c'}; sort(arrofCha);       // a, c, g, v,        |
  |}   }                                                                                            |
  |_________________________________________________________________________________________________|
  - Makes the methods and classes compatible with any type of data (Integer, String, ... etc., and user-defined types).
  - Handles type checking during instantiation (compile-time); thereby most errors appear at compile-time rather than at run-time. So generics enhances reliability.
  - Have no run-time overhead where code is generated by text subsitution (code is dublicated on the fly) then compiled. So genetics is the best generalization 
    technique when we are dealing with algorithms and data structures as it does not affect run-time performance.